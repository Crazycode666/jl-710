# ANC扩展功能说明

![ANC扩展功能](./assets/ANC-EXT_func.jpg)<br>

## 名词解释
|名词|描述|
|----|---|
|**ADT** | Acoustic Detector 声音检测|
|**SPEAK_TO_CHAT** |智能免摘|
|**WIDE_AREA_TAP** | 广域点击|
|**WIND_NOISE_DET** | 风噪检测|
|**VOLUME_ADAPTIVE** | 音量自适应 |
|**FIT_DET** |贴合度检测|
|**EAR_ADAPTIVE**| 耳道自适应|
|**RTANC**|Real Time ANC，全时/实时自适应|
|**RTAEQ/AEQ**|自适应EQ|
|**RTCMP/CMP**|ANC自适应CMP|

## 智能免摘
### 功能简介
耳机检测到佩戴者说话的时候，暂停正在播放的音乐，切换到通透模式捕捉环境声音，使佩戴者听取外界声音方便与人交谈；如果在指定时间内没有检测到佩戴者说话，会退出免摘模式恢复播歌，切换到之前的状态。<br>
- 触发方式：启动后实时检测
- 输入：免摘状态
- 输出：
    - 免摘触发：切到通透模式、暂停播放
    - 免摘退出：切回之前模式、恢复播放

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 3MIC 方案（TALK+FF+FB）**
    - 使用3个麦：TALK MIC、FF MIC、FB MIC做检测，需配置`音频配置`-`ANC配置`-`左声道FF MIC`、`左声道FB MIC`和`TALK MIC`；旧版本SDK（`JL709N patch_03`以下版本或其他系列），需正确配置通话算法节点的TALK MIC

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|智能免摘|×|√|√|√|×|

### 软件配置

（1）在audio_anc.h支持通过宏SPEAK_TO_CHAT_ANC_MODE_ENABLE配置可以打开智能免摘的模式<br>
```c
//************************************************************************//
//                 ICSD ADT 相关功能配置                                  //
//************************************************************************//
#define AUDIO_ANC_WIDE_AREA_TAP_EVENT_SYNC      1//广域点击左右耳同步使能

/*支持开免摘的anc模式*/
#define SPEAK_TO_CHAT_ANC_MODE_ENABLE			(ANC_ON_BIT)

/*anc on自动打开免摘，anc off自动关闭免摘*/
#define SPEAK_TO_CHAT_AUTO_OPEN_IN_ANC          0

//****************** ICSD ADT 相关功能配置 end ************************//
```

（2）在audio_anc.h支持通过宏SPEAK_TO_CHAT_AUTO_OPEN_IN_ANC配置是否anc on自动打开免摘，anc off自动关闭免摘<br>

### 调试方法
智能免摘需原厂协助开发，开发流程如下：<br>
![开发流程](./assets/original_debug_process.png)<br>

### API使用说明

（1）智能免摘相关的接口<br>
```c
/*打开智能免摘*/  
int audio_speak_to_chat_open();  

/*关闭智能免摘*/  
int audio_speak_to_chat_close();  

/*获取智能免摘是否打开*/  
u8 audio_speak_to_chat_is_running();  

/*获取智能免摘状态*/  
u8 get_speak_to_chat_state();  

/*设置免摘定时结束的时间，单位ms*/  
int audio_speak_to_char_end_time_set(u16 time);  

/*智能免摘使用demo*/
void audio_speak_to_chat_demo(); 
```

## 风噪检测
### 功能简介
在ANC（主动降噪）系统中，风噪是一种低中频、非平稳噪声，ANC模式下会引入"呼呼"的噪声；通过实时检测风噪强度并动态调节ANC增益，在抑制风噪异响与保持降噪深度之间实现最优平衡。<br>
- 触发方式：启动后实时检测
- 输入：风噪阈值，最多划分5个等级
- 输出：调ANC增益，默认调FF，可选FB、FF+FB（视CPU支持情况）

|特性|700N|701N|708N|709N|
|---|---|---|---|---|
|FF/FB独立增益|×|×|√|√|

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 2MIC 单馈FF（TALK+FF）、 TWS 3MIC 方案（TALK+FF+FB）**
    - 使用2个麦：TALK MIC和FF MIC做检测，需配置`音频配置`-`ANC配置`-`左声道FF MIC`和`TALK MIC`；旧版本SDK（`JL709N patch_03`以下版本或其他系列），需正确配置通话算法节点的TALK MIC
- **头戴式 单馈FF / 头戴式 混合馈HYBRID**
    - 使用2个麦：LFF MIC和RFF MIC做检测

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|风噪检测|×|√|√|√|×|

### 软件配置

（1）可通过串口打印或者在icsd_adt_app.h里面打开ICSD_ADT_WIND_INFO_SPP_DEBUG_EN，然后用手机蓝牙串口工具连接样机接收风噪值<br>
```c

/* 通过蓝牙spp发送风噪信息
 * 需要同时打开TCFG_BT_SUPPORT_SPP和APP_ONLINE_DEBUG*/
#define ICSD_ADT_WIND_INFO_SPP_DEBUG_EN  1
```

### 调试方法

（1） <mark>**SDK版本 `JL709N patch_03`及以上版本，支持客户自主调试，可参考《JL实时自适应调试指南》**<mark><br>
- 调试完成后导出anc_ext.bin 下载到小机
    - anc_ext.bin 文件路径：.\SDK\cpu\br**\tools\anc_ext.bin

（2）**旧版本SDK及其他系列，风噪检测需原厂协助开发, 开发流程如下：<br>**

1) 开发流程图<br>
![开发流程](./assets/original_debug_process.png)<br>
<br>

2) 在程序icsd_adt_app.c的wind_lvl_det_anc参数里面，可配置5个风噪阈值划分6个不同的风噪等级（包括无风档位）<br>
```c
/*风噪输出等级:0~255*/
typedef struct {
    const u16 lvl1_thr;   //阈值1
    const u16 lvl2_thr;   //阈值2
    const u16 lvl3_thr;   //阈值3
    const u16 lvl4_thr;   //阈值4
    const u16 lvl5_thr;   //阈值5
    const u16 dithering_step; //消抖风噪等级间距
    u8 last_lvl;
    u8 cur_lvl;
} wind_lvl_det_t;
wind_lvl_det_t wind_lvl_det_anc = {
    .lvl1_thr = 30,
    .lvl2_thr = 60,
    .lvl3_thr = 90,
    .lvl4_thr = 120,
    .lvl5_thr = 150,
    .dithering_step = 10,
    .last_lvl = 0,
    .cur_lvl = 0,
};
```

3) 在程序icsd_adt_app.c的audio_anc_wind_noise_process函数里面，可以设置不同风噪等级下的ANC增益<br>
```C

/*anc风噪检测的处理*/
void audio_anc_wind_noise_process(u8 wind_lvl)
{
   ...

    hdl->adt_wind_gain_lvl = anc_wind_noise_lvl;

    u16 anc_fade_gain = 16384;
    /*根据风噪等级改变anc增益*/
    switch (anc_wind_noise_lvl) {
    case ANC_WIND_NOISE_LVL0:
        anc_fade_gain = 16384;
        break;
    case ANC_WIND_NOISE_LVL1:
        anc_fade_gain = 10000;
        break;
    case ANC_WIND_NOISE_LVL2:
        anc_fade_gain = 8000;
        break;
    case ANC_WIND_NOISE_LVL3:
        anc_fade_gain = 6000;
        break;
    case ANC_WIND_NOISE_LVL4:
        anc_fade_gain = 3000;
        break;
    case ANC_WIND_NOISE_LVL5:
    case ANC_WIND_NOISE_LVL_MAX:
        anc_fade_gain = 0;
        break;
    default:
        anc_fade_gain = 0;
        break;
    }

   ...
}
```

### API使用说明
（1）风噪检测相关的api接口<br>
```c
/*打开风噪检测*/
int audio_icsd_wind_detect_open();
/*关闭风噪检测*/
int audio_icsd_wind_detect_close(); 

/*获取风噪等级*/
u8 get_audio_icsd_wind_lvl();

/*风噪检测使用demo*/
void audio_icsd_wind_detect_demo(); 
```

（2）在程序icsd_adt_app.c的wind_info_anc结构体参数里面，可通过fade_in_time和fade_out_time两个成员
变量配置不同风噪等级的淡入淡出时间，单位是秒<br>
```c
typedef struct {
    u16 time;//定时器定时计算时间, ms
    u32 fade_timer;//计算定时器
    u32 wind_cnt;//记录单次定时器的风噪帧数
    u32 wind_eng;//记录风噪等级累加数字
    u8 last_lvl;//记录上一次风噪等级
    u8 preset_lvl;//记录当前检测到的风噪等级
    u8 fade_in_cnt;//记录风噪变大的次数
    u8 fade_out_cnt;//记录风噪变小的次数
    u8 wind_process_flag;//是否条件anc增益

    u8 fade_in_time;//设置淡入时间，单位s，误差1s
    u8 fade_out_time;//设置淡出时间，单位s，误差1s
    float ratio_thr;//设置判断阈值百分比，范围：0~1
} wind_info_t;
static wind_info_t wind_info_anc = {
    .time = 1000, //ms
    .fade_timer = 0,
    .wind_cnt = 0,
    .wind_eng = 0,
    .last_lvl = 0,
    .preset_lvl = 0,
    .fade_in_cnt = 0,
    .fade_out_cnt = 0,
    .wind_process_flag = 0,
    .fade_in_time = 4, //s
    .fade_out_time = 10, //s
    .ratio_thr = 0.8f,
};

```

## 广域点击
### 功能简介
使用麦克风检测点击后脸颊或者耳廓的的情况当作按键使用，减少硬件成本<br>
- 触发方式：启动后实时检测
- 输入：广域点击标志
- 输出：对应按键事件

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 2MIC 混合馈（FF+FB）、 TWS 3MIC 方案（TALK+FF+FB）**
    - 使用2个麦：FF MIC、FB MIC做检测；<br>

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|广域点击|×|√|√|√|×|

### 软件配置

（1）在audio_anc.h通过宏AUDIO_ANC_WIDE_AREA_TAP_EVENT_SYNC配置是否把单耳点击事件同步到对耳<br>
```c

//************************************************************************//
//                 ICSD ADT 相关功能配置                                  //
//************************************************************************//
#define AUDIO_ANC_WIDE_AREA_TAP_EVENT_SYNC      1//广域点击左右耳同步使能

/*支持开免摘的anc模式*/
#define SPEAK_TO_CHAT_ANC_MODE_ENABLE			(ANC_ON_BIT)

/*anc on自动打开免摘，anc off自动关闭免摘*/
#define SPEAK_TO_CHAT_AUTO_OPEN_IN_ANC          0

//****************** ICSD ADT 相关功能配置 end ************************//

```

### 调试方法

广域点击需原厂协助开发，开发流程如下：<br>
![开发流程](./assets/original_debug_process.png)<br>

### API使用说明

（1）广域点击相关的api接口<br>
```c
/*打开广域点击*/
int audio_wat_click_open();

/*关闭广域点击*/
int audio_wat_click_close();

/*广域点击使用demo*/
void audio_wat_click_demo();
```

（2）在icsd_adt_app.c的audio_wat_area_tap_event_handle()函数里面配置不同点击下的响应事件<br>
```C
/*广域点击事件处理*/
void audio_wat_area_tap_event_handle(u8 wat_result)
{
    switch (wat_result) {
    case WIND_AREA_TAP_DOUBLE_CLICK:
        /*音乐暂停播放*/
        if ((bt_get_call_status() == BT_CALL_OUTGOING) ||
            (bt_get_call_status() == BT_CALL_ALERT)) {
            bt_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
        } else if (bt_get_call_status() == BT_CALL_INCOMING) {
            bt_cmd_prepare(USER_CTRL_HFP_CALL_ANSWER, 0, NULL);
        } else if (bt_get_call_status() == BT_CALL_ACTIVE) {
            bt_cmd_prepare(USER_CTRL_HFP_CALL_HANGUP, 0, NULL);
        } else {
            bt_cmd_prepare(USER_CTRL_AVCTP_OPID_PLAY, 0, NULL);
        }
        break;
    case WIND_AREA_TAP_THIRD_CLICK:
        /*anc切模式*/
        anc_mode_next();
        break;
    case WIND_AREA_TAP_MULTIPLE_CLICK:
        /* tone_play_index(IDEX_TONE_NUM_4, 0); */
        break;
    }
}

```

## 音量自适应
### 功能简介
根据当前环境噪声的大小，自动设置当前播歌音量的大小，环境噪声越大，设置的播歌音量越大，避免噪声把音乐声覆盖而导致听不到播歌的音乐声<br>
- 输入：环境噪声阈值
- 输出：播歌音量

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 2MIC 混合馈（FF+FB）、 TWS 3MIC 方案（TALK+FF+FB）**
    - 使用2个麦：FF MIC、FB MIC做检测；<br>

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|音量自适应|×|√|√|√|×|

### 软件配置

（1）可通过串口打印或者在icsd_adt_app.h里面打开ICSD_ADT_VOL_NOISE_LVL_SPP_DEBUG_EN，然后用手机蓝牙串口工具连接样机接收噪声大小信息<br>
```c

/* 通过蓝牙spp发送噪声大小信息
 * 需要同时打开TCFG_BT_SUPPORT_SPP和APP_ONLINE_DEBUG*/
#define ICSD_ADT_VOL_NOISE_LVL_SPP_DEBUG_EN  1
```

### 调试方法

（1）音量自适应需原厂协助开发，开发流程如下：<br>
![开发流程](./assets/original_debug_process.png)<br>

（2）在icsd_adt_app.c的avc_parm结构体里面配置音量自动调节逻辑参数<br>
```c
struct adaptive_vol_param {
    u8 noise_lvl_thr;/*噪声阈值*/
    float offset_dB;/*小于噪声阈值的音量偏移*/
};
/*将音量划分5个不同的区间，每一个区间下，不同大小的噪声，设置不同的音量偏移大小*/
#define VOLUME_LEVEL    5
/*将噪声大小划分6个等级*/
#define NOISE_LEVEL     6

static const struct adaptive_vol_param avc_parm[VOLUME_LEVEL][NOISE_LEVEL + 1] = {
    /*第1区间的音量: cur_vol < max_vol * 1/VOLUME_LEVEL*/
    {
        {40, 0},//噪声小于40，音量+0dB
        {45, 8},//噪声在40~45，音量+8dB
        {50, 16},//噪声在45~50，音量+16dB
        {60, 20},//噪声在50~60，音量+20dB
        {70, 25},
        {80, 30},
        {90, 35}
    },
#if (VOLUME_LEVEL >= 2)
    /*第2区间的音量: cur_vol < max_vol * 2/VOLUME_LEVEL , cur_vol >= max_vol * 1/VOLUME_LEVEL*/
    {
        {40, 0},
        {45, 4},
        {50, 8},
        {60, 10},
        {70, 14},
        {80, 18},
        {90, 22}
    },
#endif
    ...
    ...
    ...
};
```
- **参数配置说明：**<br>
    默认参数里面，把音量从小到大划分5个区间，在每个音量区间内，再把噪声大小划分6个等级，每个噪声等级对应设置一个音量的变化大小，音量变化单位dB。参数支持自行增加或者减小音量区间数量和噪声等级数量。

### API使用说明
（1）音量自适应相关的api接口<br>
```c
/*打开音量自适应*/
int audio_icsd_adaptive_vol_open();

/*关闭音量自适应*/
int audio_icsd_adaptive_vol_close();

/*音量自适应使用demo*/
void audio_icsd_adaptive_vol_demo();
```

## 贴合度检测
### 功能简介
贴合度检测是指通过播放提示音，麦克风收集耳道佩戴特征信息，输出贴合度阈值; 提示用户是否已佩戴好耳机，通过手动调整至合适的佩戴位置，以享受最佳音质或降噪体验。
- 触发方式：主动调用1次，播放提示音
- 输入：耳道/佩戴信息
- 输出：贴合度阈值（分档 佩戴松/正常/紧）

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 带有FB MIC的方案**
    - 使用1个麦：FB MIC做检测；<br>

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|贴合度检测|×|√|√|√|×|

### 软件配置
- **提示音配置**：配置如下图，**默认SDK使用耳道自适应的提示音**，贴合度检测需要特殊的提示音，需要质量比较好的提示音格式，如MTY/SBC等：
![贴合度检测提示音](./assets/ANC-ear_adaptive_tone.jpg)<br>
<br>
- 提示音配置位置
```c
//文件路径 icsd_afq_app.c
//AFQ提示音文件选择
#define AUDIO_AFQ_TONE_FILE_SEL              get_tone_files()->anc_adaptive
```
- 贴合度阈值配置
```c
/*
    佩戴松紧度阈值thr
    1、thr > DOT_NORM_THR                    判定:紧
    2、DOT_NORM_THR >= thr > DOT_LOOSE_THR   判定:正常
    3、DOT_LOOSE_THR  >= thr                 判定:松
*/
#define ICSD_DOT_NORM_THR                    0.0f
#define ICSD_DOT_LOOSE_THR                  -6.0f
```

### 调试方法
- 通过主动调用api接口触发贴合度检测
- 分别佩戴 松/正常/紧，根据打印得到该样机的贴合度阈值（注意因样机不同，得到的贴合度范围可能差异较大）
    -   贴合度阈值相关性：松 < 正常 < 紧
```
[00:00:38.825]========================================= 
[00:00:38.825]                    dot db = 85/100 
[00:00:38.825]========================================= 
[00:00:38.825] dot: tight 
```
- 多个样机，多次不同佩戴，根据阈值分布划分档位；可将贴合度阈值上报至APP 分档提示

### API使用说明
```c
//文件路径 icsd_demo.c

/*
   贴合度运行结束回调
	param: result 贴合度阈值，用户判断松紧度
 */
void audio_dot_end_result(int result)
{
    /*
     	AUDIO_FIT_DET_RESULT_TIGHT
    	AUDIO_FIT_DET_RESULT_NORMAL
    	AUDIO_FIT_DET_RESULT_LOOSE
    */
    printf("dot end %d\n", result);
}

/*
*********************************************************************
*                  audio_dot_app_open
* Description: 单次（贴合度检测）
* Note(s)    : 播提示音 + 贴合度检测, 运行结束调用audio_dot_end_result
*********************************************************************
*/
int audio_dot_app_open(void)
{
    int ret = 0;

    //选择数据来源AFQ
    int fre_sel = AUDIO_ADAPTIVE_FRE_SEL_AFQ;

#if TCFG_AUDIO_FIT_DET_ENABLE
    //1. 注册 贴合度检测 流程
    ret = audio_icsd_dot_open(fre_sel, audio_dot_end_result);
    if (ret) {
        printf("fit_det open fail\n");
        goto __exit;
    }
#endif

#if TCFG_AUDIO_FREQUENCY_GET_ENABLE
    //2.播放提示音-启动算法流程
    ret = audio_icsd_afq_open(1);
    if (ret) {
        printf("afq open fail\n");
        goto __exit;
    }
#endif

    return 0;
__exit:	//处理启动异常的问题

    printf("fail process\n");
#if TCFG_AUDIO_FIT_DET_ENABLE
    audio_icsd_dot_close();
#endif
    return ret;
}

```

## 耳道自适应
### 功能简介

ANC降噪效果与耳机佩戴松紧度，以及用户的耳道差异息息相关；耳道自适应技术，通过麦克风收集用户耳道特性和佩戴情况的声学特征信息，自适应调整降噪参数，以提供更加舒适和个性化的降噪体验；
- 优势：补全不同人耳道的佩戴差异
- 触发方式：主动调用1次，播放提示音，生成符合当前耳道的滤波器
- 输入：耳道/佩戴信息
- 输出：调滤波器/增益。

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 2MIC 混合馈（FF+FB）、 TWS 3MIC 方案（TALK+FF+FB）**
    - 使用2个麦：FF MIC、FB MIC做检测；<br>
- **头戴式 混合馈（LFF+LFB+RFF+RFB）**
    - 使用4个麦：LFF MIC、LFB MIC、RFF MIC、RFB MIC做检测；<br>

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|耳道自适应|×|√|√|√|×|

### 软件配置
- **提示音配置**：配置如下图，自适应需要特殊的提示音，会提供默认提示音`Adaptive ANC Tone1/2/3`，需要质量比较好的提示音格式，如MTY/SBC等，如需自定义提示音，可将提示音发给原厂检查是否满足要求：
![耳道自适应提示音](./assets/ANC-ear_adaptive_tone.jpg)<br>
<br>

- 每次切降噪模式，都触发耳道自适应，配置以下宏定义即可
```c
#define ANC_EAR_ADAPTIVE_EVERY_TIME		1   /*每次切ANC_ON都进行自适应*/
```

### 调试方法
- 自适应参数配置及调试方法：参考《JL耳道自适应调试指南》，导出anc_ext.bin下载到小机
- anc_ext.bin 文件路径：.\SDK\cpu\br**\tools\anc_ext.bin

### API使用说明

```c

/*自适应模式-重新检测
 * param: tws_sync_en          1 TWS同步自适应，支持TWS降噪平衡，需左右耳一起调用此接口
 *                             0 单耳自适应, 不支持TWS降噪平衡，可TWS状态下单耳自适应
 */
int audio_anc_mode_ear_adaptive(u8 tws_sync_en);

/*
   强制中断自适应
   param: default_flag		1 退出后恢复默认ANC效果； 0 退出后保持ANC_OFF(避免与下一个切模式流程冲突)
 */
void anc_ear_adaptive_forced_exit(u8 default_flag);

/*
   自适应/普通参数切换（只切换参数）
	param:  mode 		0 使用普通参数; 1 使用自适应参数
			tone_play 	0 不播放提示音；1 播放提示音
			update_flag 0 不更新效果；	1 即时更新效果
 */
int audio_anc_coeff_adaptive_set(u32 mode, u8 tone_play);

/*ANC滤波器模式循环切换*/
int audio_anc_coeff_adaptive_switch();

/*当前ANC滤波器模式获取 0:普通参数 1:自适应参数*/
int audio_anc_coeff_mode_get(void);

```

### 示例代码
```c
//切换耳道自适应滤波器，更新效果
audio_anc_coeff_adaptive_set(1,0);  //切换自适应滤波器
audio_anc_param_reset(1);           //（可选）复位ANC，更新参数效果；需在ANC模式下

//切换默认滤波器，更新效果
audio_anc_coeff_adaptive_set(0,0);  //切换默认滤波器
audio_anc_param_reset(1);           //（可选）复位ANC，更新参数效果；需在ANC模式下
```

### FAQ
- Q: **耳道自适应的场景互斥问题**
    - A: 
        - 前置条件：ANC模式下支持进入耳道自适应；
        - 播歌：会打断背景音乐，等自适应完成之后再继续播放
        - 通话：不支持耳道自适应；
        - 其他功能互斥：智能免摘/贴合度检测/场景自适应等功能，SDK 默认会关闭，等自适应完成再打开；
- Q: **耳道自适应的参数是如何保存的？**
    - A: 耳道自适应的参数是保存在vm中的，自适应结束会使用自适应参数，并保存到vm，后续切降噪模式都会使用自适应参数，如果需要恢复默认ANC参数则调用`audio_anc_coeff_adaptive_set`接口设置


## 自适应CMP
### 功能简介
ANC Music Cancel滤波器（简称CMP）的参数一般参考耳道金机佩戴手动拟合，当佩戴差异较大时，默认CMP滤波器贴合不准，影响耳机音质，在**TWS半入耳方案**方案中问题表现更加明显；自适应CMP根据耳道状态自适应调整CMP的参数，改善音质体验；
- 触发方式：跟随耳道自适应/实时自适应输出, **建议有ANC自适应的产品同步打开此功能**
- 输入：耳道自适应/实时自适应 输出的耳道频响信息
- 输出：ANC CMP滤波器参数

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 2MIC 混合馈（FF+FB）、 TWS 3MIC 方案（TALK+FF+FB）**
    - 使用2个麦：FF MIC、FB MIC做检测；<br>
- **头戴式 混合馈（LFF+LFB+RFF+RFB）**
    - 使用4个麦：LFF MIC、LFB MIC、RFF MIC、RFB MIC做检测；<br>

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|自适应CMP|×|√|√|√|×|

### 调试方法
- 自适应CMP参数配置及调试方法：参考以下文档，导出anc_ext.bin下载到小机
    - 单次耳道自适应CMP：参考《JL耳道自适应调试指南》
    - 实时自适应CMP：参考《JL实时自适应调试指南》
- anc_ext.bin 文件路径：.\SDK\cpu\br**\tools\anc_ext.bin

### API使用说明
 - 嵌套在耳道自适应/实时自适应启动接口中，没有单独的API开关


## 自适应EQ
根据耳道结构/佩戴差异，自适应调整EQ滤波器；避免因佩戴松紧度差异，导致EQ频段失衡导致音乐低频被过度抵消或放大的问题；
- 触发方式：跟随耳道自适应/实时自适应输出, 或主动调用AEQ接口触发
- 输入：耳道自适应/实时自适应 输出的耳道频响信息、AEQ接口独立获取的频响信息
- 输出：EQ滤波器

### 功能简介
### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 2MIC 混合馈（FF+FB）、 TWS 3MIC 方案（TALK+FF+FB）**
    - 使用2个麦：FF MIC、FB MIC做检测；<br>

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|自适应EQ|×|√|√|√|×|

### 软件配置
- **功能绑定**：
    - **贴合度检测**：因为AEQ需要根据贴合度调整EQ参数，所以需要绑定贴合度检测功能

![贴合度检测使能](./assets/aeq_fit_det_en.png)<br>

- **AEQ节点配置**：如下图，<mark>需在`音频流程`-`媒体` 数据流中添加EQ节点，并命名为**AEQ**, 否则无法启用</mark>

![AEQ节点配置](./assets/aeq_stream_node.png)<br>
<br>

### 调试方法
- 自适应EQ参数配置及调试方法：参考以下文档，导出anc_ext.bin下载到小机
    - 单次耳道自适应EQ：参考《JL耳道自适应调试指南》
    - 实时自适应EQ：参考《JL实时自适应调试指南》
- anc_ext.bin 文件路径：.\SDK\cpu\br**\tools\anc_ext.bin

### API使用说明

```c
//(实时)自适应EQ打开
int audio_real_time_adaptive_eq_open(enum audio_adaptive_fre_sel fre_sel, void (*result_cb)(int result));

//(实时)自适应EQ退出
int audio_real_time_adaptive_eq_close(void);

//查询AEQ的状态
u8 audio_adaptive_eq_state_get(void);

/*
   自适应EQ滤波器模式设置
   param: mode 0 默认参数； 1 自适应参数
   note: 需注意，调用该接口后，全局有效，如使用默认参数，则下次自适应也不会更新参数

*/
int audio_adaptive_eq_eff_set(enum ADAPTIVE_EFF_MODE mode);

//删除AEQ 自适应系数记忆链表，需等下次自适应输出才有自适应参数
int audio_adaptive_eq_cur_list_del(void);

```

### 示例代码

- **单次自适应EQ （+ 其他算法）**
```c
//文件路径 ： icsd_demo.c

/*
    单次（自适应EQ）
        播放提示音，输出EQ滤波器
    note  : 播提示音 + 自适应EQ, 运行结束调用audio_adaptive_eq_end_result
*/
int audio_adaptive_eq_app_open(void);

/*
    单次（ANC耳道自适应 + 自适应EQ + 贴合度检测）
        播放提示音，输出EQ滤波器 + ANC滤波器，贴合度检测结果
    note  : ANC耳道自适应输出的SZ，挂载多个算法处理
*/
int audio_ear_adaptive_app_open_demo(void);
```
- **实时自适应EQ + RTANC**
```c
//文件路径 ： icsd_demo.c

/*
    实时（RTANC + 自适应EQ）
        实时监测耳道，自适应调整EQ和ANC滤波器
    note  : 由ANC实时自适应输出的SZ，挂载多个算法处理
*/
int audio_real_time_adaptive_app_open_demo(void)

/*
    关闭实时（RTANC + 自适应EQ）
*/
int audio_real_time_adaptive_app_close_demo(void)
```

### FAQ
- **Q：自适应 EQ参数 有效业务场景是哪些？**
    - A：依赖于数据流`AEQ`名称的EQ节点，默认仅有`媒体`数据流场景生效
- **Q：EQ参数自适应后是否保留？**
    - A：每次自适应EQ参数输出成功后，会自动保存到RAM，下次启动后会自动加载，掉电不保存；
- **Q：如何切到默认EQ参数，或清除自适应EQ参数？**
    - A: 调用audio_adaptive_eq_eff_set(AEQ_EFF_MODE_DEFAULT)，即可切到默认EQ参数；调用audio_adaptive_eq_cur_list_del()，即可清除自适应EQ参数；
- **Q：有多组EQ音效是否需要匹配多个自适应EQ参数？**
    - A：不需要，自适应EQ是独立的EQ节点，其参数由算法根据佩戴状态生成，与其他EQ节点的参数无关；   


## 全时/实时自适应

### 功能简介
ANC降噪效果与耳机佩戴松紧度，以及用户的耳道差异息息相关；耳道自适应技术，通过麦克风收集用户耳道特性和佩戴情况的声学特征信息，自适应调整降噪参数，以提供更加舒适和个性化的降噪体验；
- 优势：实时检测，补全不同人耳道的佩戴差异
- 触发方式：启动后实时监测
- 输入：耳道/佩戴信息
- 输出：调滤波器/增益

### 系统/硬件支持
**（1）支持方案**<br>
- **TWS 3MIC 方案（TALK+FF+FB）：推荐方案，较好兼容自讲场景**
    - 使用3个麦：TALK MIC、FF MIC、FB MIC做检测；<br>
- **TWS 2MIC 方案（TALK+FF+FB）：**
    - 使用2个麦：FF MIC、FB MIC做检测；<br>

**（2）CPU平台差异**<br>
|特性|700N|701N|708N|709N|710N|
|---|---|---|---|---|---|
|实时自适应|×|×|×|√|×|

### 软件配置

- 实时自适应参数保存配置
```c
/*
   RTANC 开关或模式切换时，是否保持上一次的效果参数, 工具/产测流程 固定使用默认参数
   0 使用默认参数
   1 参数保持，工具/产测使用默认参数
   2 参数保持(所有流程)，测试验证使用
*/
#define AUDIO_RT_ANC_KEEP_LAST_PARAM            1       //启用后，默认保留RTANC CMP/FB参数
#define AUDIO_RT_ANC_KEEP_FF_COEFF              0       //在以上宏的基础上选择是否保留RTANC FF参数
```

### 调试方法
- 实时耳道自适应参数配置及调试方法：参考《JL实时自适应调试指南》，导出anc_ext.bin下载到小机
- anc_ext.bin 文件路径：.\SDK\cpu\br**\tools\anc_ext.bin

### API使用说明

```c

/*
   实时自适应ANC打开
*/
int audio_anc_real_time_adaptive_open(void);

/*
   实时自适应ANC关闭
*/
int audio_anc_real_time_adaptive_close(void);

/*
   实时自适应ANC挂起
   param:name 挂起名称标识
*/
void audio_anc_real_time_adaptive_suspend(const char *name);

/*
   实时自适应ANC恢复
   param:name 恢复名称标识，需与挂起名称标识一致
*/
void audio_anc_real_time_adaptive_resume(const char *name);

/*
   实时自适应ANC状态获取
*/
u8 audio_anc_real_time_adaptive_state_get(void);

```

### 示例代码

- **实时自适应EQ + RTANC**
```c
//文件路径 ： icsd_demo.c

/*
    实时（RTANC + 自适应EQ）
        实时监测耳道，自适应调整EQ和ANC滤波器
    note  : 由ANC实时自适应输出的SZ，挂载多个算法处理
*/
int audio_real_time_adaptive_app_open_demo(void)

/*
    关闭实时（RTANC + 自适应EQ）
*/
int audio_real_time_adaptive_app_close_demo(void)
```

### FAQ
- **Q：实时自适应关闭后，RTANC参数是否保留？**
    - A：关闭RTANC，默认保留CMP/FB参数:
        - 若需要保留FF参数，需要在`rt_anc_app.h`中配置`AUDIO_RT_ANC_KEEP_FF_COEFF`为1；
        - 如不需要保留RTANC参数，需要在`rt_anc_app.h`中配置`AUDIO_RT_ANC_KEEP_LAST_PARAM`为0
- **Q：实时自适应需要保持anc fade gain = 16384(0dB)**
    - A：因此当触发调anc fade gain行为，均会挂起RTANC，比如风噪检测、环境自适应、手动调fade增益档位等；


## 算法业务场景互斥

### 算法功能开关控制逻辑

#### 设计意义

- 用于解决因需求不同或资源不足，需要在不同业务场景下，裁剪ANC算法功能：
    - 例：某方案因资源不足，需要在空间音效、通话场景关闭风噪检测、RTANC等
- 用户层可使用按键/手机APP 独立控制各类算法
- 算法控制优先级：场景限制 > 用户层APP控制 > ANC模式切换 默认启用算法类型

#### 策略说明
- <mark>**适用**本策略的算法</mark>
    - 智能免摘、风噪检测、广域点击、环境自适应、啸叫检测、RTANC 等ADT相关算法
- <mark>**不适用**本策略的算法</mark>
    - 单次耳道自适应、单次CMP、单次AEQ、贴合度检测<br>
![算法功能使能逻辑](./assets/anc_ext_open_check.png)<br>
<br>
- APP 功能开关：即用户层调用各类算法的接口，在各功能`API使用说明`、`示例代码` 的接口，，比如`audio_anc_real_time_adaptive_open`
- APP 启动功能标志更新：记录当前用户层启动了什么算法；
- 业务场景检查：根据 `audio_anc_manager.c` 的 `anc_ext_support_scene`数组，判断当前业务场景是否支持该算法，做进一步筛选，是否允许启动；
- 算法启动：启动ANC_EXT相关算法；
- ANC模式切换：切换通透、降噪、关闭模式
- APP 启动标志检查：如检查存在功能标志，则会经过业务场景检查，并启动此标志对应算法；

#### 业务场景检查
- 业务场景数组说明
```c
//文件路径：icsd_adt_app.h

//ANC扩展功能场景支持定义
enum ICSD_ADT_SCENE {
    //-------USER SCENE------------
    ADT_SCENE_IDEL          = 0,
    ADT_SCENE_A2DP          = BIT(0),	//A2DP场景
    ADT_SCENE_ESCO          = BIT(1),	//ESCO场景
    ADT_SCENE_MIC_EFFECT    = BIT(2),	//MIC混响场景
    ADT_SCENE_TONE          = BIT(3),	//提示音场景(未启用)
    ADT_SCENE_ANC_OFF       = BIT(4),	//ANC_OFF场景
    ADT_SCENE_ANC_TRANS     = BIT(5),	//通透场景
    //用户定义场景在此添加

    //------SDK FIX SCENE 默认不支持ADT---------
    ADT_SCENE_AFQ           = BIT(16),
    ADT_SCENE_PRODUCTION    = BIT(17),
};


// 文件路径：audio_anc_manager.c

/*
   配置不同业务场景下支持ANC_EXT 算法功能
   1、ANC模式、IDLE场景默认全支持
   2、多场景共存时，以不支持的场景优先
   3、数组修改注意
   		1）scene 需与枚举 enum ICSD_ADT_SCENE 的 USER SCENE 对齐
   		2）算法  需与枚举 enum ICSD_ADT_MODE  对齐
*/
const u8 anc_ext_support_scene[6][10] = {
    //0-智能免摘 1-风噪检测 2-广域点击 3-NULL 4-RTANC 5-入耳检测 6-环境自适应 7-NULL 8-NULL 9-啸叫检测
    { 1,         1,         1,         0,     1,      1,         1,           0,     0,     1         }, //A2DP场景
    { 0,         0,         0,         0,     1,      0,         0,           0,     0,     1         }, //ESCO场景
    { 0,         0,         0,         0,     1,      0,         0,           0,     0,     1         }, //MIC混响场景
    { 0,         0,         0,         0,     0,      0,         0,           0,     0,     0         }, //提示音场景
    { 0,         0,         0,         0,     1,      0,         0,           0,     0,     0         }, //ANC_OFF场景
    { 1,         1,         1,         0,     0,      1,         1,           0,     0,     1         }, //通透场景
    //用户可在此添加其他场景，注意修改数组大小以及对齐枚举ICSD_ADT_SCENE的 USER SCENE
};
```
- 新增业务场景关联案例<br>
    - 因某方案ram不足，空间音效只能开风噪检测

```c
/*-----------------Step 1 新增场景定义-----------------*/
enum ICSD_ADT_SCENE {
    //-------USER SCENE------------
    ...
    //用户定义场景在此添加
    ADT_SCENE_SPACE_EFFECT = BIT(6),	//空间音效场景

    //------SDK FIX SCENE 默认不支持ADT---------
    ...
};


/*-----------------Step 2 新增场景支持定义-------------*/
const u8 anc_ext_support_scene[7][10] = {
    //0-智能免摘 1-风噪检测 2-广域点击 3-NULL 4-RTANC 5-入耳检测 6-环境自适应 7-NULL 8-NULL 9-啸叫检测
    ...
    //用户可在此添加其他场景，注意修改数组大小以及对齐枚举ICSD_ADT_SCENE的 USER SCENE
    { 0,         1,         0,         0,     0,      0,         0,           0,     0,     0         }, //空间音效场景
};


/*-----------------Step 3 场景启动关联-----------------*/
int audio_space_effect_open(void)   //空间音效 启动（伪代码）
{
    //开启空间音效场景
    audio_icsd_adt_scene_set(ADT_SCENE_SPACE_EFFECT, 1);
    //复位ANC算法
    audio_icsd_adt_reset(ADT_SCENE_SPACE_EFFECT);

    //空间音效开启流程...
    return 0;
}

int audio_space_effect_close(void)   //空间音效 关闭（伪代码）
{    
    //空间音效关闭流程...

    //关闭空间音效场景
    audio_icsd_adt_scene_set(ADT_SCENE_SPACE_EFFECT, 0);
    //复位ANC算法
    audio_icsd_adt_reset(ADT_SCENE_SPACE_EFFECT);
    return 0;
}
```

- ANC 默认启动算法控制
    - 可根据ANC默认切换模式的需求，修改此函数
```c
// 文件路径：audio_anc_manager.c

//ANC模式切换时，启动算法功能 - 后续可被模块单独开关替代
int audio_anc_app_adt_mode_init(u8 enable);
```

## 扩展功能打印控制

### 基本描述
ANC扩展功能的打印非常多，默认不常开；但在debug，尤其性能相关的问题，需要打开并提供相关打印信息给原厂算法同事，才能较好的还原问题现场，协助分析问题。

### 打印控制位置
- APP层打印 - 文件icsd_common_v2_app.h
```c

//============ANC_EXT APP打印管理=========
#define ICSD_ADT_RTANC_OFFLINE_PRINTF      1   //RTANC 离线log 使能 （200ms/次）
#define ICSD_WIND_LVL_PRINTF               1   //风噪阈值打印使能
#define ICSD_ENV_LVL_PRINTF                1   //环境自适应阈值打印使能

```

- 算法层打印 - 文件icsd_common_v2.h
```c
//============算法库轻量信息打印使能=========
#define ICSD_ADT_LOG_EN                    0//ADT公共部分
#define ICSD_HOWL_LOG_EN                   0//啸叫检测
#define ICSD_RTANC_LOG_EN                  1//实时自适应

//============算法库打印使能=================
#define ADT_PRINTF_EN                      0 //ADT资源
#define VDT_PRINTF_EN                      0 //智能免摘
#define WAT_PRINTF_EN                      0 //广域点击
#define CMP_PRINTF_EN                      0 //自适应CMP
#define AEQ_PRINTF_EN                      0 //自适应EQ
#define AFQ_PRINTF_EN                      0 //AFQ
#define AVC_PRINTF_EN                      0 //AVC
#define DOT_PRINTF_EN                      0 //松紧度检测
#define EIN_PRINTF_EN                      0 //
#define HOWL_PRINTF_EN                     0 //啸叫检测
#define RTANC_RTPRINTF_EN                  0 //实时自适应ANC RT
#define RTANC_HZPRINTF_EN                  0 //实时自适应ANC HZ
#define ADJDCC_PRINTF_EN                   0 //自适应DCC


//===========风噪调试使能====================
#define WDT_PRINTF_EN                      0 //算法打印
#define ICSD_WDT_LOG_EN                    0 //离线log打印
#define WDT_LFF_TLK_DEBUG_EN               0 //LFF_TLK模式离线调试打印
#define WDT_LFF_LFB_DEBUG_EN               0 //LFF_LFB模式离线调试打印
#define WDT_LFF_RFF_DEBUG_EN               0 //LFF_RFF模式离线调试打印

```



