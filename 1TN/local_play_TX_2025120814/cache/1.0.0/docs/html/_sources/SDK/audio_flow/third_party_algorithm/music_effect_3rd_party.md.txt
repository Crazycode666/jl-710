# 音乐算法集成

## 功能介绍
音乐播放通路，集成第三方音效算法，客户可以在节点流程里面实现自己的自定义算法

## 开发流程
**（1）音频流程添加第三方音效开发节点**<br>
根据实际需要，可以添加一个或多个自定义算法节点`EffectDev`<br>
![EffectDev](./assets/EffectDev.png)

**（2）自定义算法开发位置**<br>
自定义节点0路径：`audio/framework/nodes/effect_dev0_node.c`<br>
自定义节点1路径：`audio/framework/nodes/effect_dev1_node.c`<br>
自定义节点2路径：`audio/framework/nodes/effect_dev2_node.c`<br>
自定义节点3路径：`audio/framework/nodes/effect_dev3_node.c`<br>
自定义节点4路径：`audio/framework/nodes/effect_dev4_node.c`<br>
以EffectDev0开发为例：<br>
- `初始化接口`<br>
audio_effect_dev0_init函数中添加自定义算法初始化处理
```C

 /* 自定义算法，初始化
 * hdl->dev.sample_rate:采样率
 * hdl->dev.in_ch_num:通道数，单声道 1，立体声 2, 四声道 4
 * hdl->dev.out_ch_num:通道数，单声道 1，立体声 2, 四声道 4
 * hdl->dev.bit_width:位宽 0，16bit  1，32bit
 **/
static void audio_effect_dev0_init(struct effect_dev0_node_hdl *hdl)
{
    //TODO
}
```

- `运行接口`<br>
audio_effect_dev0_run函数中添加自定义算法运行处理
```C
 /* 自定义算法，运行
 * hdl->dev.sample_rate:采样率
 * hdl->dev.in_ch_num:通道数，单声道 1，立体声 2, 四声道 4
 * hdl->dev.out_ch_num:通道数，单声道 1，立体声 2, 四声道 4
 * hdl->dev.bit_width:位宽 0，16bit  1，32bit
 * *indata:输入数据地址
 * *outdata:输出数据地址
 * indata_len :输入数据长度,byte
 * */
static void audio_effect_dev0_run(struct effect_dev0_node_hdl *hdl, s16 *indata, s16 *outdata, u32 indata_len)
{
#if 0
    //test 2to4
    if (hdl->dev.bit_width && ((hdl->dev.out_ch_num == 4) && (hdl->dev.in_ch_num == 2))) {
        pcm_dual_to_qual_with_slience_32bit(outdata, indata, indata_len, 0);
    }
#endif

    //TODO
}
```
- `退出关闭接口` <br>
audio_effect_dev0_exit函数中添加自定义算法关闭处理
```C
/* 自定义算法，关闭
 * */
static void audio_effect_dev0_exit(struct effect_dev0_node_hdl *hdl)
{
    //TODO

}
```

**（3）自定义算法-固定输入帧长**<br>
用于处理算法需要固定帧长输入的场景
```C
/* 音效算法处理帧长
 * 0   : 等长输入输出，输入数据算法需要全部处理完
 * 非0 : 按照EFFECT_DEV0_FRAME_POINTS 固定帧长输入数据到算法处理接口                                    
 */
#define EFFECT_DEV0_FRAME_POINTS  (256) 
```

**（4）自定义算法-固定输入输出通道**<br>
用于处理算法固定输入/输出通道的场景，当通道不匹配时，可能会存在参数协商失败的问题；<br>
若算法固定输入通道，在effect_dev 之前添加Channel_Merge/Channel_Expander节点<br>
若算法固定输出通道，在effect_dev 后添加Channel_Merge/Channel_Expander节点<br>

+ Channel_Merge节点
    + 声道合并
    + 参数说明：
        + auto : 根据声道自定义适配，数据处理通常为(L+R)/2
        + stereo_to_mono : 立体声->单声道
        + qual_to_stero : 四声道->立体声
        + qual_to_mono : 四声道->单声道
        + tws_auto : 根据TWS声道状态，立体声->TWS L声道 or TWS R声道

+ Channel_Expander 节点
    + 声道拓展，自适应根据通道协商，用于立体声->四声道、单声道->立体声；

+ 使用demo<br>
![EffectDev](./assets/3rd_party_channel_adpter.png)

**（5）自定义算法-参数配置**<br>
![EffectDev](./assets/3rd_party_param.png)
- 默认预留的参数
```c
struct user_effect_tool_param {
    int   int_param[8];
    float float_param[8];
};
```
- 数据流启动时获取配置文件内参数、在线调试的临时参数，参数数据保存在节点句柄中
```c
/*节点start函数*/
static void effect_dev0_ioc_start(struct effect_dev0_node_hdl *hdl)
{
    ......
    /*
     *获取配置文件内的参数,及名字
     * */
    int len = jlstream_read_node_data_new(hdl_node(hdl)->uuid, hdl_node(hdl)->subid, (void *)&hdl->cfg, hdl->name);
    if (!len) {
        log_error("%s, read node data err\n", __FUNCTION__);
        return;
    }
    /*
     *获取在线调试的临时参数
     * */
    if (config_audio_cfg_online_enable) {
        if (jlstream_read_effects_online_param(hdl_node(hdl)->uuid, hdl->name, &hdl->cfg, sizeof(hdl->cfg))) {
            log_debug("get effect dev0 online param\n");
        }
    }
    ......
}
```
- 在线调试更新参数
```c
/* 自定义算法，更新参数
 **/
static void audio_effect_dev0_update(struct effect_dev0_node_hdl *hdl)
{
    //打印在线调音发送下来的参数
    printf("effect dev0 name : %s \n", hdl->name);
    for (int i = 0 ; i < 8; i++) {
        printf("cfg.int_param[%d] %d\n", i, hdl->cfg.int_param[i]);
    }
    for (int i = 0 ; i < 8; i++) {
        printf("cfg.float_param[%d] %d.%02d\n", i, (int)hdl->cfg.float_param[i], debug_digital(hdl->cfg.float_param[i]));
    }
    //do something

}
```

**（6）2TO4声道转换处理**<br>
```c
/*
 *声道转换类型选配
 *支持立体声转4声道协商使能,须在第三方音效节点后接入声道拆分节点
 * */
#define CHANNEL_ADAPTER_AUTO   0 //自动协商,通常用于无声道数转换的场景,结果随数据流配置自动适配
#define CHANNEL_ADAPTER_2TO4   1 //立体声转4声道协商使能,支持2to4,结果随数据流配置自动适配
#define CHANNEL_ADAPTER_1TO2   2 //单声道转立体声协商使能,支持1to2,结果随数据流配置自动适配
#define CHANNEL_ADAPTER_TYPE   CHANNEL_ADAPTER_2TO4  //默认选配支持2to4协商
```
+ 使用demo<br>
![EffectDev](./assets/effect_dev_channel_adapter.png)

**（7）硬件eq接口**<br>

接口定义见effcts/audio_hw_crossover.h头文件
```c
/*eq 打开
 *coeff:nsection个二阶IIR滤波器。每5个系数对应一个二阶的IIR滤波器。
        每个系数都是float类型,左右声道使用同一分系数.
        b0 b1 b2 a1 a2对应coeff排列如下：
                                        coeff[0]:b0
                                        coeff[1]:-a2
                                        coeff[2]:b2 / b0
                                        coeff[3]:-a1
                                        coeff[4]:b1 / b0
 *nsection    :系数表的段数(二阶滤波器个数)
 *sample_rate :采样率
 *ch_num      :通道数（1声道还是2声道)
 *in_mode     :eq输入数据位宽，2:float, 1：输入32bit数据， 0：输入16bit是数据
 *out_mode    :eq输出数据位宽，2:float, 1：输出32bit数据， 0：输出16bit是数据
 *return      :返回句柄
 * */
void *audio_eq_coeff_open(void *coeff, u8 nsection, u32 sample_rate, u32 ch_num, u32 in_mode, u32 out_mode);

/*eq 处理
 *hdl        :audio_eq_coeff_open返回的句柄
 *indata     :输入buf
 *outdata    :eq处理后输出数据存放的buf
 *indata_len :输入数据的字节长度,单位byte
 * */
void audio_eq_coeff_run(void *hdl, void *indata, void *outdata, u32 indata_len);

/*eq 更新滤波器系数
 *hdl   :audio_eq_coeff_open返回的句柄
 *coeff :需要更新的滤波器系数（段数不可变）
 * */
void audio_eq_coeff_update(void *hdl, void *coeff);

/*eq 关闭
 *hdl  :audio_eq_coeff_open返回的句柄
 * */
void audio_eq_coeff_close(void *hdl);


void *user_eq_hdl;
float user_coeff[5] = {1, 0, 0, 0, 0}; //直通的系数
void audio_hw_eq_process_demo()
{
    u32 ch_num = 2;	//通道数
    u32 sample_rate = 44100;//采样率
    u32 in_bit_width = 1;//32bit
    u32 out_bit_width = 1;//32bit
    u8 nsection = 1;//滤波器个数
    
    //open
    user_eq_hdl = audio_eq_coeff_open(user_coeff, nsection, sample_rate, ch_num, in_bit_width, out_bit_width);

    //run
    s16 *in_data_addr = ?;
    s16 *out_data_addr = ?;
    u32 in_data_len = ?;
    audio_eq_coeff_run(user_eq_hdl, in_data_addr, out_data_addr, in_data_len);

    //update ceoff tab
    //set coeff to eq
    audio_eq_coeff_update(user_eq_hdl, user_coeff);

    //close
    audio_eq_coeff_close(user_eq_hdl);
    user_eq_hdl = NULL;
}


```